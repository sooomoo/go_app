// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"goapp/internal/app/stores/dao/model"
)

func newUserAccountBinding(db *gorm.DB, opts ...gen.DOOption) userAccountBinding {
	_userAccountBinding := userAccountBinding{}

	_userAccountBinding.userAccountBindingDo.UseDB(db, opts...)
	_userAccountBinding.userAccountBindingDo.UseModel(&model.UserAccountBinding{})

	tableName := _userAccountBinding.userAccountBindingDo.TableName()
	_userAccountBinding.ALL = field.NewAsterisk(tableName)
	_userAccountBinding.ID = field.NewInt64(tableName, " id")
	_userAccountBinding.AccountType = field.NewUint8(tableName, "account_type")
	_userAccountBinding.Account = field.NewString(tableName, "account")
	_userAccountBinding.BoundAt = field.NewString(tableName, "bound_at")
	_userAccountBinding.Status = field.NewUint8(tableName, "status")

	_userAccountBinding.fillFieldMap()

	return _userAccountBinding
}

// userAccountBinding 账户绑定，如邮箱，微信等
type userAccountBinding struct {
	userAccountBindingDo

	ALL         field.Asterisk
	ID          field.Int64
	AccountType field.Uint8  // 账户类型：微信，邮箱等等
	Account     field.String // 具体账户：邮箱，微信 openid 等
	BoundAt     field.String // 绑定时间
	Status      field.Uint8  // 状态：正常，解绑等等

	fieldMap map[string]field.Expr
}

func (u userAccountBinding) Table(newTableName string) *userAccountBinding {
	u.userAccountBindingDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userAccountBinding) As(alias string) *userAccountBinding {
	u.userAccountBindingDo.DO = *(u.userAccountBindingDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userAccountBinding) updateTableName(table string) *userAccountBinding {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt64(table, " id")
	u.AccountType = field.NewUint8(table, "account_type")
	u.Account = field.NewString(table, "account")
	u.BoundAt = field.NewString(table, "bound_at")
	u.Status = field.NewUint8(table, "status")

	u.fillFieldMap()

	return u
}

func (u *userAccountBinding) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userAccountBinding) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 5)
	u.fieldMap[" id"] = u.ID
	u.fieldMap["account_type"] = u.AccountType
	u.fieldMap["account"] = u.Account
	u.fieldMap["bound_at"] = u.BoundAt
	u.fieldMap["status"] = u.Status
}

func (u userAccountBinding) clone(db *gorm.DB) userAccountBinding {
	u.userAccountBindingDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userAccountBinding) replaceDB(db *gorm.DB) userAccountBinding {
	u.userAccountBindingDo.ReplaceDB(db)
	return u
}

type userAccountBindingDo struct{ gen.DO }

type IUserAccountBindingDo interface {
	gen.SubQuery
	Debug() IUserAccountBindingDo
	WithContext(ctx context.Context) IUserAccountBindingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserAccountBindingDo
	WriteDB() IUserAccountBindingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserAccountBindingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserAccountBindingDo
	Not(conds ...gen.Condition) IUserAccountBindingDo
	Or(conds ...gen.Condition) IUserAccountBindingDo
	Select(conds ...field.Expr) IUserAccountBindingDo
	Where(conds ...gen.Condition) IUserAccountBindingDo
	Order(conds ...field.Expr) IUserAccountBindingDo
	Distinct(cols ...field.Expr) IUserAccountBindingDo
	Omit(cols ...field.Expr) IUserAccountBindingDo
	Join(table schema.Tabler, on ...field.Expr) IUserAccountBindingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserAccountBindingDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserAccountBindingDo
	Group(cols ...field.Expr) IUserAccountBindingDo
	Having(conds ...gen.Condition) IUserAccountBindingDo
	Limit(limit int) IUserAccountBindingDo
	Offset(offset int) IUserAccountBindingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserAccountBindingDo
	Unscoped() IUserAccountBindingDo
	Create(values ...*model.UserAccountBinding) error
	CreateInBatches(values []*model.UserAccountBinding, batchSize int) error
	Save(values ...*model.UserAccountBinding) error
	First() (*model.UserAccountBinding, error)
	Take() (*model.UserAccountBinding, error)
	Last() (*model.UserAccountBinding, error)
	Find() ([]*model.UserAccountBinding, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserAccountBinding, err error)
	FindInBatches(result *[]*model.UserAccountBinding, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserAccountBinding) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserAccountBindingDo
	Assign(attrs ...field.AssignExpr) IUserAccountBindingDo
	Joins(fields ...field.RelationField) IUserAccountBindingDo
	Preload(fields ...field.RelationField) IUserAccountBindingDo
	FirstOrInit() (*model.UserAccountBinding, error)
	FirstOrCreate() (*model.UserAccountBinding, error)
	FindByPage(offset int, limit int) (result []*model.UserAccountBinding, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserAccountBindingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userAccountBindingDo) Debug() IUserAccountBindingDo {
	return u.withDO(u.DO.Debug())
}

func (u userAccountBindingDo) WithContext(ctx context.Context) IUserAccountBindingDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userAccountBindingDo) ReadDB() IUserAccountBindingDo {
	return u.Clauses(dbresolver.Read)
}

func (u userAccountBindingDo) WriteDB() IUserAccountBindingDo {
	return u.Clauses(dbresolver.Write)
}

func (u userAccountBindingDo) Session(config *gorm.Session) IUserAccountBindingDo {
	return u.withDO(u.DO.Session(config))
}

func (u userAccountBindingDo) Clauses(conds ...clause.Expression) IUserAccountBindingDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userAccountBindingDo) Returning(value interface{}, columns ...string) IUserAccountBindingDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userAccountBindingDo) Not(conds ...gen.Condition) IUserAccountBindingDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userAccountBindingDo) Or(conds ...gen.Condition) IUserAccountBindingDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userAccountBindingDo) Select(conds ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userAccountBindingDo) Where(conds ...gen.Condition) IUserAccountBindingDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userAccountBindingDo) Order(conds ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userAccountBindingDo) Distinct(cols ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userAccountBindingDo) Omit(cols ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userAccountBindingDo) Join(table schema.Tabler, on ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userAccountBindingDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userAccountBindingDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userAccountBindingDo) Group(cols ...field.Expr) IUserAccountBindingDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userAccountBindingDo) Having(conds ...gen.Condition) IUserAccountBindingDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userAccountBindingDo) Limit(limit int) IUserAccountBindingDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userAccountBindingDo) Offset(offset int) IUserAccountBindingDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userAccountBindingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserAccountBindingDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userAccountBindingDo) Unscoped() IUserAccountBindingDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userAccountBindingDo) Create(values ...*model.UserAccountBinding) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userAccountBindingDo) CreateInBatches(values []*model.UserAccountBinding, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userAccountBindingDo) Save(values ...*model.UserAccountBinding) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userAccountBindingDo) First() (*model.UserAccountBinding, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserAccountBinding), nil
	}
}

func (u userAccountBindingDo) Take() (*model.UserAccountBinding, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserAccountBinding), nil
	}
}

func (u userAccountBindingDo) Last() (*model.UserAccountBinding, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserAccountBinding), nil
	}
}

func (u userAccountBindingDo) Find() ([]*model.UserAccountBinding, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserAccountBinding), err
}

func (u userAccountBindingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserAccountBinding, err error) {
	buf := make([]*model.UserAccountBinding, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userAccountBindingDo) FindInBatches(result *[]*model.UserAccountBinding, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userAccountBindingDo) Attrs(attrs ...field.AssignExpr) IUserAccountBindingDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userAccountBindingDo) Assign(attrs ...field.AssignExpr) IUserAccountBindingDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userAccountBindingDo) Joins(fields ...field.RelationField) IUserAccountBindingDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userAccountBindingDo) Preload(fields ...field.RelationField) IUserAccountBindingDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userAccountBindingDo) FirstOrInit() (*model.UserAccountBinding, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserAccountBinding), nil
	}
}

func (u userAccountBindingDo) FirstOrCreate() (*model.UserAccountBinding, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserAccountBinding), nil
	}
}

func (u userAccountBindingDo) FindByPage(offset int, limit int) (result []*model.UserAccountBinding, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userAccountBindingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userAccountBindingDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userAccountBindingDo) Delete(models ...*model.UserAccountBinding) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userAccountBindingDo) withDO(do gen.Dao) *userAccountBindingDo {
	u.DO = *do.(*gen.DO)
	return u
}
